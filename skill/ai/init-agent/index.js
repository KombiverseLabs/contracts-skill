#!/usr/bin/env node
// PoC Init Agent - Scans repository and generates CONTRACT.md and CONTRACT.yaml drafts
// Usage: node index.js --path . --dry-run

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { spawnSync } = require('child_process');

function walkDirs(root, patterns) {
  const found = [];
  for (const p of patterns) {
    const base = path.join(root, p.replace('/*', ''));
    if (fs.existsSync(base) && fs.statSync(base).isDirectory()) {
      const subdirs = fs.readdirSync(base, { withFileTypes: true }).filter(d => d.isDirectory()).map(d => path.join(base, d.name));
      found.push(...subdirs);
    }
  }
  return found;
}

function templateFor(type, name) {
  // Simple templates - can be replaced by LLM-generated text
  if (type === 'core') return `# ${name}\n\n## Purpose\n[1-2 sentences: Foundational responsibility this module owns]\n\n## Core Features\n- [ ] Feature 1\n- [ ] Feature 2\n\n## Constraints\n- MUST: [Critical requirement]\n- MUST NOT: [What this module should never do]\n\n## Success Criteria\n[Measurable]\n`;
  return `# ${name}\n\n## Purpose\n[1-3 sentences: Why does this exist?]\n\n## Core Features\n- [ ] Feature 1\n- [ ] Feature 2\n\n## Constraints\n- MUST: [Requirement]\n\n## Success Criteria\n[How do we know it's working]\n`;
}

function makeYaml(name, type, relPath, hash) {
  return `# CONTRACT.yaml - Technical specification derived from CONTRACT.md\n# Auto-generated by init-agent\n\nmeta:\n  source_hash: "${hash}"\n  last_sync: "${new Date().toISOString()}"\n  tier: ${type === 'core' ? 'core' : 'standard'}\n  version: "1.0"\n\nmodule:\n  name: "${name}"\n  type: "${type}"\n  path: "${relPath.replace(/\\\\/g,'/')}"\n\nfeatures: []\n\nconstraints:\n  must: []\n  must_not: []\n\nrelationships:\n  depends_on: []\n  consumed_by: []\n\nvalidation:\n  exports: []\n  test_pattern: "*.test.ts"\n  custom_script: null\n\nchangelog:\n  - date: "${new Date().toISOString().slice(0,10)}"\n    version: "1.0"\n    change: "Initial contract (auto-generated)"\n    author: "init-agent"\n`;
}

function sha256(content) {
  const h = crypto.createHash('sha256');
  h.update(content);
  return 'sha256:' + h.digest('hex');
}

function diffText(original, generated) {
  // Try to use git diff --no-index if available
  try {
    const tmp1 = path.join(process.env.TEMP || '/tmp', `orig-${Date.now()}.tmp`);
    const tmp2 = path.join(process.env.TEMP || '/tmp', `new-${Date.now()}.tmp`);
    fs.writeFileSync(tmp1, original || '', 'utf8');
    fs.writeFileSync(tmp2, generated, 'utf8');
    const res = spawnSync('git', ['--no-pager', 'diff', '--no-index', '--color=always', tmp1, tmp2], { encoding: 'utf8' });
    fs.unlinkSync(tmp1); fs.unlinkSync(tmp2);
    return res.stdout || res.stderr || (`-- no diff available --`);
  } catch (e) {
    return `-- generated content --\n\n${generated}`;
  }
}

function scanAndDraft(root) {
  const modulePatterns = ['src/features/*', 'src/core/*', 'src/lib/*', 'packages/*', 'apps/*'];
  const modules = walkDirs(root, modulePatterns);
  const results = [];
  for (const m of modules) {
    const rel = path.relative(root, m);
    const name = path.basename(m);
    const type = rel.startsWith('src/core') ? 'core' : 'feature';
    const contractMd = path.join(m, 'CONTRACT.md');
    const contractYaml = path.join(m, 'CONTRACT.yaml');
    const existMd = fs.existsSync(contractMd);
    const existYaml = fs.existsSync(contractYaml);
    const mdContent = templateFor(type, name);
    const hash = sha256(mdContent);
    const yamlContent = makeYaml(name, type, rel, hash);
    let mdDiff = '';
    let yamlDiff = '';
    if (existMd) {
      const orig = fs.readFileSync(contractMd, 'utf8');
      mdDiff = diffText(orig, mdContent);
    } else {
      mdDiff = diffText('', mdContent);
    }
    if (existYaml) {
      const orig = fs.readFileSync(contractYaml, 'utf8');
      yamlDiff = diffText(orig, yamlContent);
    } else {
      yamlDiff = diffText('', yamlContent);
    }
    results.push({ path: rel, name, type, existMd, existYaml, mdContent, yamlContent, mdDiff, yamlDiff });
  }
  return results;
}

function applyDrafts(root, drafts, options) {
  const applied = [];
  for (const d of drafts) {
    const base = path.join(root, d.path);
    if (!fs.existsSync(base)) fs.mkdirSync(base, { recursive: true });
    const mdPath = path.join(base, 'CONTRACT.md');
    const yamlPath = path.join(base, 'CONTRACT.yaml');
    if (!d.existMd) fs.writeFileSync(mdPath, d.mdContent, 'utf8');
    if (!d.existYaml) fs.writeFileSync(yamlPath, d.yamlContent, 'utf8');
    applied.push({ md: mdPath, yaml: yamlPath });
    if (options.commit) {
      spawnSync('git', ['add', mdPath, yamlPath]);
    }
  }
  if (options.commit && options.commitMessage) {
    spawnSync('git', ['commit', '-m', options.commitMessage], { stdio: 'inherit' });
  }
  return applied;
}

function main() {
  const args = process.argv.slice(2);
  const root = (args.includes('--path') ? args[args.indexOf('--path')+1] : '.') || '.';
  const dry = args.includes('--dry-run') || args.includes('-n');
  const apply = args.includes('--apply');
  const commit = args.includes('--commit');
  const drafts = scanAndDraft(root);
  if (drafts.length === 0) {
    console.log('No candidate modules detected.');
    return;
  }
  console.log('Proposed contracts:');
  for (const d of drafts) {
    console.log(`\n--- ${d.path} ---`);
    console.log('\n[CONTRACT.md diff]\n');
    console.log(d.mdDiff);
    console.log('\n[CONTRACT.yaml diff]\n');
    console.log(d.yamlDiff);
  }
  if (dry) {
    console.log('\nDry-run mode: no files written. Use --apply to write files, --commit to commit.');
    return;
  }
  if (apply) {
    // require explicit confirmation
    const prompt = require('readline-sync');
    const confirm = prompt.question('Apply changes and write files to disk? (y/N) ');
    if (confirm.toLowerCase() !== 'y') { console.log('Aborted.'); return; }
    const applied = applyDrafts(root, drafts, { commit, commitMessage: 'chore: add initial contracts (init-agent)' });
    console.log('Applied:', applied);
  } else {
    console.log('\nNo action taken. Use --apply to write files, --commit to create a commit.');
  }
}

if (require.main === module) main();
